# Multi-Leader репликация

* Можем писать в любого из лидеров => уменьшаем задержку записи
* Несколько лидеров принимают запросы на запись => увеличиваем пропускную способность на запись
* Увеличиваем надёжность
	* Переживаем падение лидера
	* Даже после сбоя одного лидера можем принимать запросы и на запись, и на чтение

## Сочетаем с Leader-Follower
Схема хорошо натягивается на [[Leader-Follower репликация|Leader-Follower репликацию]]
* Несколько датацентров
* В каждом - один лидер
* У каждого лидера несколько Follower'ов
![[Pasted image 20220418191038.png]]

## Конфликты
[[Multi-leader конфликты]]

## Репликация команд и журналов

Просто пересылать команды из журнала не получится

Как не пересылать журнал целиком?

### Деревья Мёркла

Обмениваемся хешами, чтобы выяснить, чего не хватает

* Сравнивая хеши, быстро понимаем в каком поддереве произошла рассинхронизация
	* Нужно ли спускаться ниже
	* В какое поддерево спускаться, если нужно
![[Pasted image 20220418195026.png]]

### Sloppy Quorum
* При чтении с единственной реплики велик шанс прочитать устаревшее значение
	* Если читаем с медленной реплики
	* Давайте будем читать с R реплик и выбирать самое свежее значение
	* Можем прочитать несколько параллельных записей - решим конфликты
* Аналогичное верно для записи
	* Вероятно, запишем в медленную реплику
		* Наша запись не скоро отреплицируется
	* Реплика может упасть - теряем Durability
	* Будем писать в W реплик
		* Только после W записей говорим клиенту, что запись удалась
		* Можем делать эти W записей транзакционно

![[Pasted image 20220418195513.png]]
* R + W > N
	* каждая подтверждённая запись будет прочитана
* R + W <= N
	* Улучашем Durability записи
	* Уменьшаем вероятность прочитать старое значение
	* Можем не прочитать сделанную запись

### Hinted handoff
#todo 

### RSM: чтение
* У нас есть система, реализующая один из [[RSM]] протоколов
* Любая запись обрабатывается через кворум узлов
	* Все записи линеаризуются
* Чтения тоже через кворум
	* Долго

#### RSM: чтение без кворума
* Будем читать с единственного узла
	* Не инициируя стадию алгоритма
	* В [[Paxos]] это должен быть узнающий узел
* Можем прочитать старые данные
	* Т.к. практические алгоритмы консенсуса обязаны совершать прогресс даже если один узел недоступен
* Любой узел может иметь устаревшие данные
	* Даже тот, который считает себя лидером в Paxos
![[Pasted image 20220418195927.png]]
* Нужно гарантировать, что мы не прочитаем незакоммиченные данные
	* В [[Paxos]] это можно сделать
		* Каждый узнающий знает, сколько других узнающих приняли такое предложение
	* В [[RAFT]] тоже можно:
		* Лидер точно знает, на сколько узлов он реплицировал из записей собственного журнала
		* Посылает подчинённым узлам записи о коммитах
# Результат Фишера-Линча-Патерсона

В [[Синхронные и асинхронные системы#Асинхронные системы|асинхронной]] системе с [[Иерархия отказов|отказами]] невозможен алгоритм [[Консенсус|консенсуса]]

## Предпосылки
* Система [[Синхронные и асинхронные системы#Асинхронные системы|асинхронна]]
* (Один) узел может отказать (насмерть)
* [[Консенсус]] должен случиться за конечое время

## Когда можно
Выполняется хотя бы что-то из:
*  Нет отказов
*  Сеть синхронная (ограничить время доставки сообщений)
*  [[Недетерминированные алгоритмы|Алгоритм недетерминирован]]
*  Ослабить условие прогресса

## Доказательство

Пусть такой алгоритм нам предоставили

### Модель

* **Процесс** это некий ~~[[DFA]]~~ *детерминированный* автомат, который может:
	* *receive(): Msg* чтобы ожидать сообщение
		* Какое-то неограниченное время
	*  *send(Msg)* чтобы послать сообщение
		*  Может быть обработано когда-то позже
	*  *decided(value)* чтобы сказать, что решение принято
		*  Принимается единственный раз
		*  Может продолжить общаться с другими процессами
*  **Конфигурация** это
	*  Состояние всех процессов
	*  Все сообщения в пути (отправленные и не полученные)
*  **Шаг** от одной конфигурации до другой
	*  Обработка какого-то сообщения процессом (*событие*)
	*  Внутренние действия этого процесса до дех пор, пока не передйдёт к ожиданию следующего проецсса
		*  **Детерминированно**: однозначно определяется событие
*  **Начальная конфигурация** содержит начальные данные для каждого из процессов
	*  В общем-то, любые конфигурирующие данные (вроде)
		*  Начальных конфигураций много (на каждый вариант входных данных)
	*  Вообще, каждый процесс может иметь свою программу
*  **Исполнение**: бесконечная цепочка шагов от начального состояния
	*  Ибо процессы продолжают выполняться и после принятия решения
*  **Отказ**: процесс делает только *конечное* число шагов в процессе исполнения
	*  И такой процесс "от силы" один
	*  А каждый из остальных, не отказавших, делает бесконечное количество шагов
*  **Доставка**: надёжная
	*  Собщения не теряются
	*  Это вам не [[Иерархия отказов#Ненадёжная передача|omission]]
*  **Согласие** и решение. Есть [[Консенсус#Согласие]] => все процессы, пришедшие к согласию, имеют одно и то же решение $\in \{0, 1\}$
	*  Из-за возможности отказа одного процесса, даже если один не далет шагов, остальные должны прийти к решению *за конечное число шагов*
*  **Валентность**. Конфигурация называется
	*  $i$-валентной, если все цепочки шагов из неё ведут в $i \in \{0, 1\}$
	*  бивалентной, если есть цепочки шагов, приводящие как к $0$, так и к $1$
*  **Коммутируемость**
	*  Цепочки шагов с событиями на разных процессах коммутируют и приводят к одной конфигурации, если поменять их порядок выполнения

![[Pasted image 20220620205315.png]]

### Лемма 1: существует начальная бивалентная конфигурация

От противного
* Если не существует (начальной) бивалентной конфигурации, значит все конфигурации одновалентны
	* Из [[Консенсус#Нетривиальность|нетривиальности]] есть как 0-валентные, так и 1-валентные
	* Значит, найдём пару начальных конфигураций разной валентности, отличающихся начальным состоянием только одного процесса
	* Но этот процесс может оказать (не исполняться) с самого начала, и тогда одна и та же цепочка шагов (других процессов), приводящая к решению, возможно как в 0-валентной, так и в 1-валентной конфигурации => противоречие => существует начальный бивалентный класс


### Лемма 2: Для бивалентой конфигурации можно найти следующую за ней бивалентную
* Если $G$ - бивалентная конфигурация, и $e$ - какое-то событие (процесс $p$ и сообщение $m$), то возьмём
	* $C$ - множество конфигураций, достижимых из $G$ без $e$
	* $D$ - множество конфигураций $D = e(C)$, т.е. конфигураций, где $e$ это последнее событие
	![[Pasted image 20220620224002.png]]

1. Докажем, что есть $i$-валентная конфигурация $D$ для $i \in \{0, 1\}$
	1. Т.к. $G$ - бивалентная конфигурация (из [[#Лемма 1 существует начальная бивалентная конфигурация|Леммы 1]]), то по какой-то цепочке из неё можно дойти до $i$-валентной $E_i$
		* Если $E_i \in D$, то мы нашли искомую конфигурацию
		* Если $E_i \in C$, то тогда $e(C) \in D$ искомая конфигурация
		* Иначе $e$ применялась в цепочке шагов для достижения $E_i$ из $G$, а значит есть $F_i \in D$ (сразу после применения $e$), из которой доступна $E_i$ по какой-то цепочке шагов
			* По предположению, в $D$ нет бивалентных конфигураций, значит $F_i \in D$ будет $i$-валентной
	2. Можем найти такие $C_0$, $C_1$, $D_0$, $D_1$, что между $C_0$ и $C_1$ будет одно событие $e'$
		* Через $e(G)$, которое одновалентно (пусть $0$-валентно)
		* Надём $D_1$, которое $1$-валентно
		* Проходим в его $C_1$
		* Поднимаемся вверх, пока не уидим изменение валентности
	3. Два случая:
		1. $p \neq p'$, тогда $e$ и $e'$ коммутируют
			* Тогда $D_1$ должна быть и $0$-валентной, и $1$-валентной
			![[Pasted image 20220620230203.png]]
		2. $p = p'$
			* Рассмотрим такую цепочку шагов $\sigma$, в которой $p$ отказал. Тогда остальные всё ещё должны прийти к решению
			* Из $D_0$ придём к $0$, из $D_1$ - к $1$ 
			* Применим $A = \sigma(C_0)$
			* Можем прийти из него и в $0$, и в $1$
			![[Pasted image 20220620235247.png]]
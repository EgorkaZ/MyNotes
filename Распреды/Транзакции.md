# Транзакции

Иногда нам нужны согласованные изменения в [[Sharding|шардированных]] данных

Набор операций, которые должны случиться (как бы) атомарно. Пример:
```py
fun transfer(acc1, acc2, amount):
	beginTransaction()
	val b1 = loadBalance(acc1)
	check(b1 >= amount) { “Insufficient funds” }
	storeBalance(acc1, b1 – amount)
	val b2 = loadBalance(acc2)
	storeBalance(acc2, b2 + amount)
	commitTransaction()
```

## ACID
* **A**tomaicity - все изменения или никаких
* **C**onsistency - перевод системы в согласованное состояние в конце транзакции
* **I**solation - параллельные транзакции не должны влиять друг на друга, а выполняться как будто последовательно
* **D**urability - завершённые транзакции сохраняются даже в случае сбоев и перезапуска системы

### Atomicity

#### Shadow copy / Redo log
Храним "собственную версию" данных в рамках тразакции (shadow copy)
* Не делаем изменения до коммита
* Откидываем свою копию, если не судьба
* Получается **Redo log**

#### Undo log
Храним "журнал отката"
* Вносим изменения в основную копию
* Запоминаем действия, которыми можно откатить изменения
* Если отменить придётся, запускаем **Undo log**

### Durability
При завершении транзакции надо обеспечить durability
* Либо все изменения исходных данных записаны в энергонезависимую (non-volatile) память
* Либо **redo log** записан в энергонезависимую память
	* Более популярно на практике, т.к. последовательный журнал писать быстрее

### Consistency and Isolation
* Максимальный **уровень изоляции** называется **сериализуемость**
	* #def Все транзакции можно упорядочить в последовательную историю исполнения, так чтобы никакие две транзакции не выполнялись параллельно
* Фактически у транзакций должжен быть последовательный порядок (serial order) их исполнения
	* Очень похоже на _последовательную согласованность_

Самое простое - брать блокировку

Подход - двухфазная блокировка (2PL)
1. Набираем блокировки
2. Пользуемся данными
3. Отпускаем блокировки

Всё ещё нужно приходить к консенсусу о том, случился commit или rollback

#### Двухфазный коммит (2PC)

* Централизованный алгоритм завершения транзацкии
	* У каждой транзакции есть выделенный **transaction coordinator**
* **Фаза 1** Запрос (request)
	* Координатор спрашивает каждого участника о готовности к завершению транзакцию
	* Участник отвечает "yes" только если он может обеспечить завершение даже в случае сбоя (т.е. всё записано) и всё гладко, иначе "no"
	* Транзакцию можно завершить только если все участники ответили "yes"
* **Фаза 2** Завершение
	* Координатор принимает решение commit/abort и записывает
	* Координатор доводит решение до участников

Нормальное исполнение
![[Pasted image 20220404182058.png]]

* Это всё ещё консенсус, потому допустим результат [[FLP]]
	* Главная задача - ничего не потерять, потому алгоритм не завершится, пока кто-то мёртв
* При отказе узлов и связи 2PC не сможет завершиться до восстановления узлов/связи

Отказ в **фазе 1**
![[Pasted image 20220404182239.png]]

Отказ в **фазе 2**
![[Pasted image 20220404182307.png]]

Зелёненькое - запись на диск
![[Pasted image 20220404182359.png]]

Смерть координатора после записи на диск
![[Pasted image 20220404182430.png]]

Смерть координтора до записи на диск
![[Pasted image 20220404182506.png]]

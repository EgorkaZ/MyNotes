# Кеширование

## Мотивация
* Главная мотивация - уменьшение latency
	* БД это долго, дорого, фу
* Сглаживание yfuheprb
	* Популярные объекты будут часто запрашиваться из кеша
	* Тогда нагрузка на БД будет распределена более равномерно
* Задержка при чтении из кеша маленькая, т.к.
	* Кеш обчно держит все данные в RAM
	* Кеш не поддерживает персистентность
	* Кеш не поддерживает сложные индексы (почти всегда кеш то просто хеш-таблица)

## Архитектуры

### Cache Aside

* Кеш и СУБД напрямую не общаются друг с другом
* Клиент делает запросы и в кеш, и к СУБД
* Типичный пример из жизни: MySQL + Memcached
	* Почему не храним кеш на машине с клиентом? - потому что если случился популярный объект, его хотят все

![[Pasted image 20220425185403.png]]

#### Синхронные запросы
 
 * *При отсутствии* значения в кеше получаем 2 * RTT(cache) + RTT(DB) на запрос
 * *При наличии* значение в кеше получим RTT(cache)
 
 ![[Pasted image 20220425185702.png]]
 
 #### Асинхронные запросы
 
 * При отсутствии значения в кеше получаем RTT(cache) + RTT(DB) на запрос
 * Но так мы тыркаем СУБД на *каждый* запрос на чтение

![[Pasted image 20220425185931.png]]

#### Запись в СУБД

* Клиент может упасть до записи нового значения в кеш
* Тогда из кеша будем читать устаревшие данные
	* Добавим TTL (в духе [[IP packet]]) для всех значений. Будем вытеснять старые значения новыми

![[Pasted image 20220425190131.png]]

#### Cache Through

* Клиент обращается к системе СУБД + Кеш как к единой системе
	* СУБД может самостоятельно наполнять кеш результатами популярных запросов
![[Pasted image 20220425190246.png]]

## Сочетаем вместе + слабые модели консистентности

* Хотим, чтобы кеши были географически локальны
* Будем думать о кешах как об асинхронных [[Replication|репликах]]
	* Модели консистентности и алгоритмы примерно без изменений
* Можно ли писать в кеш?
	* Хотим снижать latency записи
	* Пишем в кеш без записи в СУБД
	* Будем писать в СУБД только если переполнится кеш на запись
	* Но если это кеш, который целиком в RAM и он упадёт, то всё(
* Если кеш не поддерживает персистентность, он может упасть уже после того, как подтвердил запись пользователю
	* Жертвуем [[Транзакции#ACID#Durability|Durability]]
* Если кешей, куда можем писать, несколько, это похже на [[Multi-Leader репликация]]

### Определяем отсутствие ключа
#todo
# Кворум

## Определение
#def
* Семейство подмножеств множества процессов $Q \subset 2^P$
* Если любые два кворума имеют непустое пересечение
$$\forall A,B\in Q: A \cap B \ne \varnothing$$

Т.е. у любых двух кворумов будут общие процессы. Кажется, таким образом мы гарантируем [[Happens before]] на собирании кворума

## Варианты

### Централизованный алгоритм

* Т.е. выделяем некоторый элемент $C$, который и будет выдавать решение
* Поскольку любые множества (кворумы) включают $C$, будут пересекаться на нём

Вообще, любой централизованный алгоритм можно рассмотреть как частный случай кворума

### Простое / взвешенное большинство

Простое большинство $\subset$ взвешенное: у каждого процесса вес $1$

Кворум - такое множество процессов, у которых общий вес больше половины суммарного веса всех процессов (говорят, очевидно)

[[#Централизованный алгоритм]] - тоже взвешенный: у координатора вес $1$, у остальных вес $0$

### Рушащиеся стены

А вот он особо не сводится к [[#Простое взвешенное большинство|взвешенному большинству]]

* На практике возникает, когда у нас сервера выстроены в сетку, в которой можно эффективно обмениваться сообщениями в своих строке и столбце, но неэффективно с другими
* Кворум - свой столбец + по одному элементу (любому) из каждого из остальных столбцов
* Рост количества элементов для кворума от роста числа серверов ~ $O(\sqrt{n})$ (?)
	* Если по стобцам процессы размазаны более-менее равномерно

## Взаимное исключение

Можно обеспечить [[Взаимное исключение]]: два процесса не смогут одновременно войти в КС, спрашивая разрешения у своих кворумах, т.к. на каком-то процессе эти кворумы пересекутся

Проблема:
* [[deadlock]] (один получает ответ сначала от _A_, потом от _B_, второй - наоборот)
* Решение - иерархическая блокировка
	* Т.е. упорядочим все процессы, будем просить разрешения на вход в КС по очереди у каждого
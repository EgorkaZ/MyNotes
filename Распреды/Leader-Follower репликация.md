# Leader/Follower
Похоже на [[RAFT]]

* Храним копию данных на нескольких узлах
* Один Leader
	* чтение
	* запись
* Остальные Follower'ы
	* чтение
![[Pasted image 20220418171158.png]]

Хорошо работает, когда часто читаем, но пишем редко.

## Схема
![[Pasted image 20220418171526.png]]

(Всё очень плохо, если у нас не [[FIFO  сообщения]])

### Через команды
* Лидер рассылает исполненные команды
	* Небольшой объём пересылаемых данных

#### Недетерминированные команды

* `UPDATE Table SET value = random() WHERE key = 42;`
* `INSERT INTO Table (key, time) VALUES (42, now());`
* **Решение**: место вызова недетерминированной функции пересылаем на реплику результат её исполнения
![[Pasted image 20220418171734.png]]
	
#### Проблема с конкурентностью
* На всех репликах должен быть одинаковый порядок исполнения команды
	* A: `UPDATE Table SET value = 2 WHERE value = 1;`
	* B: `UPDATE Table SET value = 3 WHERE value = 2;`
	* **Решение**: исполнять команды последовательно

## Способы передачи изменений
### Через журналы
* Лидер рассылает записи из журнала
	* Большой объём пересылаемых данных
* Определённые порядок
* Полные детерминизм
* Не пересылаем записи откаченных транзакций
* Записи из журнала очень легко применять
	* Они имеют вид: у строки R изменить значение F с Old на New
	* Команды будут очень страшными

![[Распреды/imgs/Pasted image 20220418172217.png]]

## Синхронность
### Синхронная репликация
![[Pasted image 20220418173358.png]]

#NB Лидер применяет запись последним

#### Недоступные узлы
* Если мы не можем доступиться до **хотя бы одного** узла, система не может принимать запросы на запись
* Всё ещё может читать
![[Pasted image 20220418173623.png]]

#### Нелианерзуемость
![[Pasted image 20220418180138.png]]

Как починить:
* Когда получили команду `k := v` лидер отсылает всем `SUSPEND(k)`, после которой узлы перестают отвечать на запросы по ключу `k`
* Собрав ack'и ото всех, лидер реплицирует команду `k := v`
* Собрав подтверждение успешности репликации, лидер отвечает клиенту
![[Pasted image 20220418180451.png]]

Но как же это, блять, долго

Кстати, не супер-хуже, чем [[RAFT Log Replication]]

### Асинхронная репликация
![[Pasted image 20220418173420.png]]

Так можно накапливать батчи операций и слать их разом на Follower'а (обычно так много быстрее)

#### Нелинеаризуемость

У нас может нарушаться [[Happens before]]

В отличие от [[#Синхронная репликация#Нелианерзуемость]], мы можем не увидеть завершённую операцию
![[Pasted image 20220418175958.png]]

Это нечинибельно. Но можно подумать про [[Слабые модели консистентности]]

## Масштабирование
* Чем больше реплик - тем больше времени надо потратить лидеру, чтобы переслать записи всем
* Это ограничивает масштабируемость

### Каскады репликации
![[Pasted image 20220418173943.png]]

### Gossip
* Лидер пересылает журнал не всем, а подмножеству реплик
* Дальше реплики сами пересылают друг другу недостающие фрагменты
* На каждой реплике применяем только записи из последовательного префикса, до первой "дырки"

![[Pasted image 20220418174113.png]]

Может случиться так, что какие-то реплики отстают сильно. Наверное, мы хотим выдавать таким данные в принудительном порядке

##  Снапшоты

* Подключаем к лидеру новую реплику в асинхронном режиме
	* Узел-снапшотер

### Создание снапшотов
* Передаём снапшотеру префикс лога
* Применяем на нём этот прейикс
* Получим снапшот, содержащий префикс всех операций
![[Pasted image 20220418175009.png]]

### Применение снапшота
* При подключении новой реплики не хоим передавать на неё весь журнал с первой операции
	* У нас БД может существовать годами
	* Но растёт не супер-быстро
* Инициализируем её снапшотом, отражающим операции от 1 до N
* Начнём передавать на неё журнал с N+1'й записи
![[Pasted image 20220418175220.png]]

## Практические советы
* Разные реплики могут работать в разных режимах
* Заводим одну синхронную реплику
	* Переключимся, если упадёт лидер
* Остальные работают асинхронно


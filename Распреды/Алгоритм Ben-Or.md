# Алгоритм Бен-Ора

* Множество раундов, по две фазы в раунде
	* На каждой фазе процесс ждёт поучения $N - f$ сообщений
* Фаза 1: "Предпочтение" рассылает текущее предпочтение, посылая всем сообщение $(1, k, p)$, где $k$ это номер раунда
	* Если больше $N/2$ голосов за одно значение, то **ратифицирует**
* Фаза 2: "Ратификация" шлёт $(2, k, v)$, чтобы ратифицировать значение или $(2, k, ?)$, если не набрал нужное число голосов
	* Получив хотя бы одну ратификацию (свою или от другого) на следующий раунд меняет предпочтение на полученное $v$
	* Получив больше $f$ ратификаций процесс **принимает решение** $v$ **(decide)**, но продолжает исполняться
	* Не получив ратификации, **меняет предпочтение для следующего раунда на случайное**

## Корректность

### Лемма 1
В одном раунде разные процессы не могут **ратифицировать** разные значения
* Очевидно, из-за необходимости набрать больше $N/2$ сообщений $(1, k, v)$ для ратификации $v$

### Лемма 2
Если в раунде $k$ процесс **принял решение** $v$, то $k + 1$ раунд все процессы начнут с предпочтением $v$
* Чтобы принять решение процесс получил минимум $f + 1$ сообщений вида $(2, k, v)$
	* Сообщений с другим $v$ быть не может по [[Алгоритм Ben-Or#Лемма 1|лемме 1]]
* Чтобы начать раунд с другим предпотением, процесс должен был получить $N - f$ сообщений вида $(2, k, ?)$
* Но $(f + 1) + (N - f) > f$. Противоречие

## Заключение

* Чтобы остановить алгоритм, а не исполнять его бесконечно, надо высылать третий тип сообщения **"Решение"**, как только решение принято
	* И при его получеии принимать решение и останавливаться
* Система **асинхронная** (!). Сообщения не обязаны приходить в каждый процесс "раунд за раундом"
	* Но так как на каждом раунде ждём $N - f$ сообщений, то фактически раунды получаются почти синхронными
* Даже при [[Сильный противник|сильном противнике]], решающем, в каком порядке приходят сообщения, вероятность завершения алгоритма за конечное число шагов равно 1
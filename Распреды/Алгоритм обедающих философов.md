# Алгоритм обедающих философов

Используем для алгоритма [[Взаимное исключение|взаимного исключения]]

### План
* Научимся решать задачу об обедающих философах (процессы - философы, ресурсы - вилки) в распределённой системе
* Потом обобщим на произвольный граф зависимостей

Граф зависимостей задачи об обедающих философах это цикл

### Алгоритм
* Ориентируем граф так, чтобы не было циклов
* **Теорема 1**: в ориентированном ациклическом графе всегда есть исток
* **Теорема 2**: если у истока в графе перевернуть все рёбра, он останется ациклическим
* Исток - философ, который может поесть
	* Когда он поел, переориентируем рёбра вовнутрь
	* Плохо работает, когда хочет есть только один философ
* (Ребро - вилка) классифицируем вилки как _чистые_ и _грязные_
	* _Чистая_ вилка - приоритет в данной паре
		* При запросе запомним запрос, но вилку оставим при себе (если хотим есть)
	* _Грязная_ вилка - отсутствие приоритета
		* При запросе отдадим вилку (даже если хотим есть)
		* При желании войти в КС засчитываем за вилку (как бы "моем" в момент входа в КС)
		* В этом смысле похоже на [[Алгоритм Рикарда и Агравалы]]
	* Едим когда собираем все чистые вилки

### Обобщение
* Взаимное исключение == полный граф конфликтов
* Вначале раздаём вилки, сравнивая id процессов

### Оценим
* 0 сообщений на повторный заход в КС одним процессом
* $2N - 2$ сообщений в худшем случае
* Количество сообщений пропорционально числу процессов, желающих войти в КС
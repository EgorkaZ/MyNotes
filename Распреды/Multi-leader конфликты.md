# Multi-leader конфликты
Если связь между лидерами прервалась и двум сделали противоречащие записи, случится конфликт

(См. [[Eventual consistency#Конфликты]])

## Синхронизируем консенсусом
Заюзаем [[RAFT]] или [[Paxos]] для синхронизации

## Избегание конфликтов
* Все записи, которые могут конфликтовать, прогоняем через одного лидера
* Не панацея:
	* Пользователь может переехать, запросы на изменения в его записи пойдут через другого лидера

## Векторные версии
 * На каждой реплике для каждого ключа храним вектор версий
 * k-я компонента показывает, сколько обновлений *этого ключа* с k-ой реплики мы видели
	 * Похоже на [[Векторные часы]]
 ![[Pasted image 20220418191544.png]]
 
### Обновление локальной версии
 
 * При каждом запросе на изменение увеличиваем локальную компоненту вектора на 1
	 * В векторных часах увеличивали при каждой посылке/приёмке сообщения
 * Запрос на изменение - не только Set
	 * CAS
	 * Inc
 
### Удаление устаревших версий
 
 * Реплики обмениваются локальными изменениями
	 * Вместе с версиями
 * Если A [[Happens before]] B, A может быть удалена
	 * Т.к. версия B "видела" версию A
	 * [[Happens before]] как в [[Векторные часы|векторных часах]]
	![[Pasted image 20220418191954.png]]

### Параллельные обновления
 * Определяем параллельность так же, как в векторных часах
 * Сохраним оба значения
	 * Пусть приложение решает, что с этим делать
	 * Версия получившегося значения - покомпонентный максимум из двух несравнимых векторов
	![[Pasted image 20220418192118.png]]
	
#### Решаем конфликты приложением
Зависит от хранимых данных!

* Пример: Amazon объединяет две корзины в одну
	* Можем потерять удаление из корзины
	* Добавления не теряются
![[Pasted image 20220418192250.png]]

#### Разрешаем конфликты вообще
* Приложение читает данные и понимает, что версии разошлись
* Решает конфликт, получает итоговое значение
* Записывает его в базу
	* Увеличивает локальную версию той леплики, куда новая версия будет записана
	* Результирующему занчению будут предшествовать все конфилктующие записи
	* Результирующее значение заменит любое из них
* Либо это делает сама реплика записи
![[Pasted image 20220418192534.png]]

* Конфликт может быть одновременно решён на нескольких узлах
	* Получим несравнимые вектора
* Веротность мала, так как конфликт решается при чтении клиентом
* Используем детерминированное разрешение конфликтов
![[Pasted image 20220418192836.png]]
* Вообще, конфликты могут скоммутировать

### Изменение состава кластера

#### Добавляем
* Будем хранить отображение вместо вектора
	* Ключ - имя узла
	* Значение - сколько обновлений с этого узла мы видели
* Если в отображении нет нужного нам ключа - представим, что он там есть
	* Ему соответствует значение 0
	* Разумено, так как мы не видели ни одного обновления с этого узла

#### Удаляем
* Хотим удалять старые значения
	* Соотвествующие выведенным из эксплуатации узла
* Будем на каждом узле помнить, когда в последний раз мы что-то слышали от узла
	* Будем удалять из реплики ключ, от которой слишком давно не было обновлений
	* Эта реплика мертва с наиболее высокой вероятностью

### На все конфликты: Last Write Wins

* Будем оставлять на каждой реплике только последнюю (в каком-то смысле) запись
* Нельзя на каждой реплике выбрать последнюю пришедшую запись
* Реплики могут не прийти в согласованное состояние вообще
![[Pasted image 20220418193704.png]]

#### Нарушение happens-before

Может нарушиться [[Happens before]]
![[Pasted image 20220418194151.png]]
* c -> b, a||c, a||b
* Пусть в случае параллельности выбор произваодится в следующем порядке: с (наивысший приоритет), a, b (самый никий приоритет)
* Если при конфликте мы берём покомпонентный максимум векторных версий:
	* a + c = c, a + c || b
	* *(a + c) + b = a + c = c*
	* a + b = a, c -> (a + b)
	* *(a + b) + c = a + b = a*
* Если при конфликте мы берём версию победителя
	* a + c = c, (a + c) -> b
	* *(a + c) + b = b*
	* a + b = a, (a + b) || c
	* *(a + b) + c = c*

#### Чиним (Eventual consistency)

[[Eventual consistency]]
* Нельзя держать только актуальное значение
* На каждой репилке для каждого ключа выбираем N значений: последняя полученная запись с каждой из N реплик
* Хотим получить актуальное значение ключа
	* Строим множество записей W, где каждая запись параллельна (в векторном смысле) остальным
	* Постепенно будем выкидывать те, которые [[Happens before]] существующие
	* Из множества W выберем одну операцию
	* На каждом значении - вектор версий ($N^2$ версий)


# Congestion control

Алгоритмы, которыми [[TCP]] корректирует количество засылаемых пакетов, чтобы предотвращать лишние потери

### AIMD
Additive increase, multiplicative decrease

* Пока работает, время от времени увеличиваем размер окна на 1
* Если навернулось, шлём вдвое меньше пакетов
* В среднем, используем канал на 3/4
* Сейчас не используется

### BIC
Binary increase congestion

Замедляем увеличение окна, если всё навернулось
![[Pasted image 20220407003157.png]]

### CUBIC

* Примерно то же, что делаем с BIC, но кубическая парабола роста
* Когда вышли за пределы предыдущего максимума, растём быстрее
	* Предположение - что-то в сети поменялось в лучшую сторону
* Мейнстрим

![[Pasted image 20220407003427.png]]

#### Формулка

* $\beta = 0.7$ - множитель сокращения
* $C = 0.4$ - константа скалирования
* $w_{max}$ - максимальный размер congestion window до потери
* T - время с предыдущей потери
* cwnd - текущий размер congestion window

$$ cwnd = C(T - K)^3 + w_{max} $$
$$ K = \sqrt[\Large3]{\frac{w_{max}(1 - \beta)}{C}} $$

#rfc 8312

### BBR
Bottleneck Bandwith Reduction

Идея - сокращать количество пакетов, когда они начинают долго доходить. Мы предполагаем, что где-то там на пути уже забиваются очереди маршрутизаторов, скоро поплохеет, потому мы сразу отступаем, но не сильно

Google получила крутую утилизацию трафика во внутренней сети, когда внедрила. Когда потащили в интернет - слишком задавили CUBIC: пока падал CUBIC, BBR немного сокращал аппетиты, но продолжал слать много, после чего продолжал расти
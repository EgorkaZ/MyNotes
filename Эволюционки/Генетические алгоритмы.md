# Генетические алгоритмы
* Не только оптимизатор, но и модель эволюции
* Используют не только [[Мутации|мутации]] (унарные операторы), но и [[Скрещивание|скрещивания]] (бинарные операторы)
* Как правило, применяются к задачам, заданным на строках конечной длины над фиксированным алфавитом (часто {0, 1})

## А нужно ли скрещивание?

* Много противоречивых исследований
* Противоречивые свидетельства из эволюции в природе
	* Какой-то природный рак научился размножаться бесполым путём — живёт прекрасно
* Мало теоретического понимания — до недавнего времени
	* 2011: матожидание времени работы "унарных" алгоритмов — $\large \Omega(n\log n)$, а некоторых "бинарных" — $\large O(n)$, даже на _простых задачах_
	* 2014: пример "бинарного" алгоритма с вышеуказанным свойством, агностичный относительно задачи (однако, он "капризный")

## Схема алгоритма
```rust
const pop_size: usize; // размер популяции, чётный

let mut population: Set<Unit> = repeat_with(random_solution).take(pop_size);
let mut best = population.max_by(measure);

while have_time() {
	best = population.chain(best).max_by(measure);
	let mut children = Set::new();
	
	for _ in (0..n / 2) {
		let prnt1 = reproduction_selection(&population); / #1
		let prnt2 = reproduction_selection(&population); 
		let (child1, child2) = crossover(prnt1, prnt2); / #2
		children.insert(mutate(child1));
		children.insert(mutate(child2));
	}
	population = survival_selection(population, children);
}
```

#1 Про работу `reproduction_selection` см. [[Частые операторы отбора|здесь]]
#2 Про работу `crossover` см. [[Генетические алгоритмы#Типичные скрещивания для битовых строк|скерщивание]]


## Типичные скрещивания для битовых строк
[[Скрещивание|Скрещиваем]] [[Vector#Булевы|битовые строки]]

## Варианты
* Меметические алгоритмы
	* ВНИМАНИЕ, ОБНАРУЖЕНА МЕМЕТИЧЕСКАЯ УГРОЗА
	* [[Мутации|Мутация]] включает в себя локальный поиск
		* Может быть полезно, когда ресурсов мало
* [[Генетическое программирование]]
	* Особи не фиксированной длины
* Стационарные (steady-state) варианты
	* На каждой итерации создаётся и обрабатывается одно решение. Например, $(\mu + 1)$-ГА
	* Хорошо считается распределённо, когда не знаем времени выполнения `measure`
# Генетическое программирование
Давайте выращивать программы путём эволюции

Какие программы?
* Способы аппроксимации и описания данных
	* Символьная регрессия
		* Попытка описать данные формулой, вид которой заранее неизвестен
	* [[DFA|Конечные автоматы]]-распознаватели
		* Вообще, про более ранние этапы
* Управляющие программы или протоколы
	* John Koza, 1990, "Умный муравей" и подобные исследования
		* Есть клетчатое поле, на нём есть еда, там ползает муравей, двигается по полю, поворачивается, ест. Нужно съесть побольше еды
		* Оказывается, можно автоматом описать поиск цели на поле с препятствиями
	* Много разного для разных предметных областей
		* Всякие разные процессы могут описываться автоматами
	* Некоторое время развивалось в ИТМО

Особенность: характерны довольно большие размеры популяций, поскольку дешевле в проверке

## Древовидное генетическое программирование

* **Особи**: деревья разбора программ
* **Приспособленность**: проверяем запуском программы
	* Скорее всего на каких-нибудь датасетах
![[Pasted image 20220422163301.png]]

### Компоненты дерева

* Функции нулевой арность (листья)
	* Константы
	* Переменные
	* Эфемерные константы: определяются в момент первого обращения
		* Наверное, их кто-то использует
		* Так одна программа может превращаться в семейство программ
		* Так можно имитировать шум
		* Так можно замерять противодействие каким-то отклонениям
	* Параметры: можно дополнительно настраивать в момент проверки приспособленности
	* Вызовы других деревьев (функции)
* Функции ненулевой арности (внутренние вершины)
	* Арифметические и логические операции
	* Управляющие операторы (if-then-else, while...)
	* Произвольные функции

### Сильно типизированное генетическое программирование

Иногда узлы дерева должны иметь тип. Операторы должны аккуратно обращаться с типами

Иначе если у нас все программы просто падают при запуске (скорее всего, так будет в начале), очень сложно отбирать лучшее решение

### Операторы над деревьями
#### Генерация случайных деревьев
* Нередко ограничивается максимальная глубина (иначе всё может тормозить)
* *Grow*: глубина каждого листа не превышают максимальную
	* Делаем это рекурсивно
* *Full*: глубина каждого листа равна максимальной
	* Сначала генерируем листья, затем генерируем разные комбинации
	* Обычно слишком сурово
* *RampedHalfAndHalf* - с вероятностью $p = 0.5$ вызываем в поддереве *Grow* или *Full*
* Более осмысленные варианты

#### Скрещивание

Деревья можно [[Скрещивание|скрещивать]], это довольно осмысленно

* Как правило, обмен поддеревьями
* Часто рекомендуется с вероятностью $p = 0.1$ выбирать лист, иначе обмениваться узлами
	* Как правило, листами обмениваться мало смысла, потому вероятность не очень большая
* Может радикально изменить фенотип, но при обмене схожими поддеревьями "можно жить"

![[Pasted image 20220422165046.png]]
Строим тесты к задаче о рюкзаке

#### Мутация

Ещё можно [[Мутации|мутировать]]. Зависит от операций в вершинах

* Заменить поддерево случайно сгенерированным деревом
* Заменить внутреннюю вершину одним из детей
* Заменить операцию во внутренней вершине операцией той же арности
* Поменять детей внутренней вершины, если операция не коммутативна
* Поменять два случайно выбранных поддерева
* Мутировать константу в листе
* ....и всякое тоже....

## Стековые языки

* **Идея**: давайте использовать программы на сетковых языках (вплоть до Forth)
	* Программы представляются как [[Vector]] (стек) переменной длины
		* Операторам [[Мутации|мутации]]/[[Скрещивание|скрещивания]] нужно менять длину
	* Деревья разбора не нужны
* Ещё можно делать программы, частично дописывающие себя. Если выйдет, получится кул

### Проблема

Случайно сгенерированные программы склонны делать что-то не то. Например, делить на ноль. Зачастую это как-то хакают, например, ноль выдают.

Очень часто используется [язык Push](https://faculty.hampshire.edu/lspector/push.html)

### Скрещивание

В общем, похоже на [[Vector#Булевы#Скрещивание|скрещивание векторов]]

* Имеет смысл двухточечное скрещивание, поскольку ряд инструкций это что-то осмысленное

## Проблема разрастания кода

Если размер программы не ограничивать, программа имеет тенденцию разрастаться неограниченно

Даже есть выражение "survival of the fattest" (как шутка с "survival of the fittest")

### Объяснение 1

Переобучение

* Генетическое программирование хочет описать данные как можно точнее
* Небольшие погрешности в данных -> нерегулярность -> описание растёт
	* То бишь, программа адаптируется под наши данные с их погрешностями

### Объяснение 2

Патчи и хаки

* Локально немного улучшаем функциональность программы "бизнес-ифом", увеличив её размер
* Ифу появиться проще, чем большому рефакторингу
* Характерно и для человекописных программ

### Решаем

* Жёстко ограничиваем высоту дерева
* Включаем высоту дерева как штраф для функции приспособленности
	* То бишь, лучше будут выживать более короткие программы


## А также

* [[Grammatic evolution]]
* [[Cartesian genetic programming]]
* [[Semantic genetic programming]]
* [[Genetic Improvement Programming]]
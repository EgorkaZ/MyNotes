# Генетическое программирование
Давайте выращивать программы путём эволюции

Какие программы?
* Способы аппроксимации и описания данных
	* Символьная регрессия
		* Попытка описать данные формулой, вид которой заранее неизвестен
	* [[DFA|Конечные автоматы]]-распознаватели
		* Вообще, про более ранние этапы
* Управляющие программы или протоколы
	* John Koza, 1990, "Умный муравей" и подобные исследования
		* Есть клетчатое поле, на нём есть еда, там ползает муравей, двигается по полю, поворачивается, ест. Нужно съесть побольше еды
		* Оказывается, можно автоматом описать поиск цели на поле с препятствиями
	* Много разного для разных предметных областей
		* Всякие разные процессы могут описываться автоматами
	* Некоторое время развивалось в ИТМО

Особенность: характерны довольно большие размеры популяций, поскольку дешевле в проверке

## Древовидное генетическое программирование

* **Особи**: деревья разбора программ
* **Приспособленность**: проверяем запуском программы
	* Скорее всего на каких-нибудь датасетах
![[Pasted image 20220422163301.png]]

### Компоненты дерева

* Функции нулевой арность (листья)
	* Константы
	* Переменные
	* Эфемерные константы: определяются в момент первого обращения
		* Наверное, их кто-то использует
		* Так одна программа может превращаться в семейство программ
		* Так можно имитировать шум
		* Так можно замерять противодействие каким-то отклонениям
	* Параметры: можно дополнительно настраивать в момент проверки приспособленности
	* Вызовы других деревьев (функции)
* Функции ненулевой арности (внутренние вершины)
	* Арифметические и логические операции
	* Управляющие операторы (if-then-else, while...)
	* Произвольные функции

### Сильно типизированное генетическое программирование

Иногда узлы дерева должны иметь тип. Операторы должны аккуратно обращаться с типами

Иначе если у нас все программы просто падают при запуске (скорее всего, так будет в начале), очень сложно отбирать лучшее решение

### Операторы над деревьями
#### Генерация случайных деревьев
* Нередко ограничивается максимальная глубина (иначе всё может тормозить)
* *Grow*: глубина каждого листа не превышают максимальную
	* Делаем это рекурсивно
* *Full*: глубина каждого листа равна максимальной
	* Сначала генерируем листья, затем генерируем разные комбинации
	* Обычно слишком сурово
* *RampedHalfAndHalf* - с вероятностью $p = 0.5$ вызываем в поддереве *Grow* или *Full*
* Более осмысленные варианты

#### Скрещивание

Деревья можно [[Скрещивание|скрещивать]], это довольно осмысленно

* Как правило, обмен поддеревьями
* Часто рекомендуется с вероятностью $p = 0.1$ выбирать лист, иначе обмениваться узлами
	* Как правило, листами обмениваться мало смысла, потому вероятность не очень большая
* Может радикально изменить фенотип, но при обмене схожими поддеревьями "можно жить"

![[Pasted image 20220422165046.png]]
Строим тесты к задаче о рюкзаке

#### Мутация

Ещё можно [[Мутации|мутировать]]. Зависит от операций в вершинах

* Заменить поддерево случайно сгенерированным деревом
* Заменить внутреннюю вершину одним из детей
* Заменить операцию во внутренней вершине операцией той же арности
* Поменять детей внутренней вершины, если операция не коммутативна
* Поменять два случайно выбранных поддерева
* Мутировать константу в листе
* ....и всякое тоже....

## Стековые языки

* **Идея**: давайте использовать программы на сетковых языках (вплоть до Forth)
	* Программы представляются как [[Vector]] (стек) переменной длины
	* Деревья разбора не нужны
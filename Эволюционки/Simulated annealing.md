# Имитация отжига

Два принципа

1. Иногда применять мутации, ухудшающие положение (как и в [[ЭА (1, lambda)|(1, lambda)]])
	* Так можно выйти из локального оптимума
2. Со временем вероятность ухудшить решение должна снижаться
	* Начало оптимизации — исследование среды (exploration)
	* Конец — улучшение достигнутого (exploitation)
	* Параметр $t$ — "температура" зависит от номера итерации, управляет отношением exploration/exploitation

```rust
fn Next(a: String: t: Temperature) -> String
{
	let curr = random_mutation().apply(&a);
	
	let is_better = measure(&curr) >= measure(&a);
	let change_anyway = rand(0., 1.) < exp((measure(&curr) - measure(&a)) / t);
	
	when! {
		is_better | change_anyway => curr,
		_ => a,
	}
}
```

### Проблемы

На практике имеют репутацию алгоритмов, которые надо долго настраивать под задачу

* семантика разницы в приспособленности — очень зависит от задачи
* "температура" меняется со временем, но по-хорошему, должна меняться от прогресса
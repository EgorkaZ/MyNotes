# Domination-based многокритериальное доминирование

[[Многокритериальная оптимизация#Виды алгоритмов]]

Решения ранжируются через [[Доминирование по Парето]], отношение "одинаковых" решений добивается дополнительными эвристиками

## Использование доминирования

### Dominance rank
#def **Dominance rank**: сколько решений [[Доминирование по Парето|доминируют]] текущее?
* Считается в рамках одной популяции
* На [[ЭА (1 + 1)]] ранжирование становится довольно бессмысленным

### Dominance count

#def **Dominance count**: сколько решений [[Доминирование по Парето|доминируется]] текущим
* Тоже считается на текущей популяции
* Если наше решение никого не доминирует, но никем не доминируется, то оно всё ещё интересно
	* Стоит поддерживать "уникальные" решения: dominance count == 0 => нам оно интересно


### Dominance depth

#def **Dominance depth**: на каком фронте расположено текущее решение?
* Выделяем набор решений, которые никто не доминирует, назначаем ранк 0
	* "Выбрасываем из рассматриваемых"
* Выбираем новый набор, на котором никто не доминирует, назначаем ранк 1
* И так далее

Зачастую мы сильно улучшим ситуацию, если оставлять решения не только ранка 0, но и ранк 1

![[Pasted image 20220608140233.png]]

## Примеры

### Simple Evolutionary Multiobjective Optimizer

(a.k.a. SEMO)

* Поддерживаем популяцию недоминированных решений
* На каждой итерации:
	* Генерируем одно новое решение (через [[Мутации]] / [[Скрещивание]])
	* Если оно не доминируется ни одним решением, добавим в популяцию
	* Если какие-то решения в популяции доминируются новым, удалим

#### Проблемы
* Может застрять на неоптимальном фронте
	* В целом, иногда эффективней делать прыжки из субоптимальных решений
* Популяция может разрастаться

### SPEA2

Использует [[#Dominance count]]

* Фаза 1: вычисление "силы" недоминированных особей
	* Для любого недоминированного решения $x$, $S(x) = \frac{1}{n} |\{y|x\preceq y\}|$
	* $S(x) \ge \frac{1}{n}$
	* Чем меньше $S(x)$, тем больше мы теряем, удалив $x$
* Фаза 2: вычисление качества всех особей
	* Пусть $P_0$ — множество недоминированных решений
	* Для каждого решения $y$ вычисляется следующая велчина:
	$$F(y) = \sum_{x\in P_0|x\preceq y} S(x)$$
	* Если $x \prec y$, то $F(x) \le F(y)$
	* Меньшие значения $F$ соответствуют менее населённым регионам

### NSGA-II

Говорят, хороший алгоритм, надёжный, ~~как швейцарские часы~~

#### Crowding distance

**Crowding distance** для двумерного случая: $\frac{dx}{DX} + \frac{dy}{DY}$
* Чем больше, тем решение более "уникально", тем меньше мы хотим его терять

* По каждому критерию ищем двух ближайших соседей
	* Так получаем $dx$ и $dy$
	* Для особей на краях говорим, что crowding distance = $+\infty$
* Ищем разницу по каждому критерию внутри одного фронта
	* Это $DX$ и $DY$
* Нормируем, суммируем

![[Pasted image 20220608142656.png]]

#### Параметры
* Размер популяции $N$, число критериев $K$, собственно, критерии
* [[Мутации]] и [[Скрещивание]]

#### Схема
* Порождаем $N$ случайных решений, вычисляем приспособленность, определяем [[#Dominance rank|ранги]] и [[#Crowding distance]] внутри каждого ранга
* На каждой итерации
	* Порождаем $N/2$ пар решений, каждое решение выбираем [[Частые операторы отбора#Турнирный отбор|турнирным отбором]]
		* Турнир: сначала сравниваем по рангу, потом по crowding distance
		* Хитрая группировка решений: каждое участвует ровно в двух турнирах
	* Проводим скрещивание и мутацию, вычисляем приспособленность
	* Сваливаем старых и новых особей в кучу, выбираем $N$ лучших
		* Сначала сравниваем по рангу, потом по crowding distance

## Ранжирование решений, равных по основному рангу

Как различать решения, равные по основному рангу? (Лежащие на одном фронте)

Варианты:
* Информация о разнообразии в популяции в окрестности решения
	* Расстояние до ближайшего соседа
	* Расстояния до нескольких ближайших соседей
	* Сколько решений находится внутри определённых гиперкубов
		* Можно оставить по одному решению внутри каждого
* Вклад решения в меру качества популяции
	* Насколько качество популяции уменьшится, если удалить решение?
	* [[МО на использовании индикаторов|индикаторы]]
	* Пример — [[#NSGA-II]]
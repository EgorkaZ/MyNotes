# Векторы

Или одномерные массивы фиксированного размера

* Булевы
* Вещественные
* Целочисленные
* Смешанные

## Булевы

Инициализация:
* Равновероятный выбор из $\{0, 1\}$
* Иногда стоит инициализироваться жадными решениями (например, задача о рюкзаке)

### Мутации
* Локально: инвертировать случайно выбранный бит
* Глобально: инвертировать каждый бит с вероятностью $p$
	* Рекомендация по умолчанию: $p = \frac{1}{N}$, доказуемо оптимальный выбор в своём классе задач
	* $p_i$: можно поставить вероятность [[Мутации|мутации]] в зависимость от позиции аллеля (0 или 1), фидбека от функции приспособленности
		* Эти вероятности можно дообучать по ходу дела ([[Обучение с подкреплением]])
	* [[Хорошие мысли#Инвертировать минимум один бит]]

### Скрещивание
Виды [[Скрещивание|скрещивания]]
![[Pasted image 20220220012645.png]]

* Одноточеченые и двухточечные стоит испльзовать только если есть связь между $x_i$ и $x_{i+1}$ (например, если это части двух отдельных чисел)
	* Это неправда довольно часто, тогда вредно: hitch-hiking effect
* По умолчанию вы хотите однородное скрещивание с вероятностью обмена $p$ (чаще всего $p=\frac{1}{2})$
* Работает для всех типов векторов

## Вещественные

### Мутации
```rust
	vec.into_iter()
		.map(|x| if rnd(0.0, 1.0) > p {
			return x
		} else {
			loop {
				let new_x = x + rand_func(<>);
				if min <= new_x && new_x <= max { break new_x }
			}
		})
		.collect();
```
* Будем с вероятностью $p$ менять каждый элемент вектора
* Каждый элемент остаётся в границах $[min, max]$
	* Получается гиперкубик, бтв

Виды:
*  Однородная свёртка (Bounded Uniform Convolution)
	*  Все изменения в интервале $[-bound, bound]$
	* `rand_func` это равномерное распределение: `rnd(-bound, bound)`
*  Гауссова свёртка (Gaussian Convolution)
	*  `rand_func` это нормальное распределение $\mathcal{N}(0, \sigma^2)$
	*  Эта штука, вроде, как-то поумнее

### Скрещивание
* Скрещивание на прямой
	* Проводим прямую между `l_vec` и `r_vec`
	* Делаем вдоль неё линейную комбинацию (если это имеет какой-то смысл, я линал не учил)
	```rust
	let alpha = rnd(-p, 1. + p);
	let beta = rnd(-p, 1. + p);
	l_vec.into_iter().zip(r_vec)
		.map(|(l, r)| {
			let new_l = alpha * l + (1. - alpha) * r;
			let new_r = beta * r + (1. - beta) * l;
			if in_bounds(new_l) && in_bounds(new_r) {
				(new_l, new_r)
			} else {
				(l, r)
			}
		})
	```
* Скрещивание в гиперкубе
	```rust
	l_vec.into_iter().zip(r_vec)
		.map(|(l, r)| loop {
			let alpha = rnd(-p, 1. + p);
			let beta = rnd(-p, 1. + p);
			
			let new_l = alpha * l + (1. - alpha) * r;
			let new_r = beta * r + (1. - beta) * l;
			if in_bounds(new_l) && in_bounds(new_r) {
				break (new_l, new_r)
			}
		})
	```
* [[#Булевы#Скрещивание]]

## Целочисленные перечисления
* Все должны быть интерпретированы непредвзято
* Пример [[Мутации|мутации]]: $x_i \leftarrow y_i: y_i = Rand(X), y_i \ne x_i$ 

## Числа с осмысленным расстоянием
* Близкие значения дают близкие фенотипы
* Пример элементарной [[Мутации|мутации]]: $x_i \leftarrow x_i + Rand(-1, 1)$
	* распределения могут быть и умными

## Разнородные векторы
Костыль: использовать вещественное представление и соответствующие операторы, округлять перед использованием

Нормальное решение: использовать свой оператор (в т.ч. своё позиционное скрещивание) для каждого гена
* Возможная реализация: своя хромосома для каждого типа переменных
* Аккуратнее с мутациями: независимый запуск локальной мутации для каждой хромосомы - это не то, что вам надо!
	* При испльзовании библиотек это легко не заметить
# Соревновательная коэволюция с двумя популяциями

Вид [[Коэволюция|коэволюции]]

* Пример: генерация программ против набора тестов
	* Первая популяция: особи, являющиеся решениями исходной [[Задача оптимизации#задачи оптимизации]]
	* Вторая популяция: особи-тесты, которые со временем станут сложными экземплярами задачи
	* Классически пример: [[Генетические алгоритмы|генетический алгоритм]] сортирующих сетей
		* как составить электрическую сеть (набор инструкций) для сортировки $N$ [[Vector#Булевы|регистров]]
* #NB Оптимизаторы для разных популяций могут быть разными!
	* Зачастую тесты эволюционируют сильно быстрее, в итоге им дают менее "торопящиеся" алгоритмы
* Вычисление приспособленности:
	* Состязание с *текущим* поколением соперников
		* Есть риск зациклиться в своём движении
	* Состязание с *предыдущим* поколением соперников
		* Вроде, частично нивелируется проблема остановки в какой-то одной области оптимума

## Lexicase Selection

Как выполнять отбор, если приспособленность счиатется на тестах?

Особи как-то отработали на тестах, какая лучше?

* Сеттинг: множество особей-решений $\mathcal{N}$, множество тестов $\matchcal{L}$, $f(x\in \mathcal{N}, y\in \mathcal{L})$
* Агрегация приспособленностей $f(x) = F_{y\in\mathcal{L}}[f(x,y)]$ теряет много информации
	* То бишь, как-то усреднять данные на тестах - такое себе

### Удачное решение

* Отбор **одного** решения: начинаем со всей популяции $S_0$
* На итерации $t \ge 1$:
	* Выбираем случайный неиспользованный тест $y\in\mathcal{L}$
	* Находим $f_t = \max_{\Large x\in S_{t-1}} f(x,y)$
		* Лучший результат по приспособленности на этом тесте
	* $S_t = \{x\in S_{t-1}|f(x,y)=f_t\}$
		* Находим всех особей с таким результатом
	* Если $|S_t| = 1$, возвращаем единственный элемент
	* Если тесты кончились, возвращаем случайный элемент из $S_t$
* Варианты: дискретизация $f(x,y)$, выбор семантически подобной особи
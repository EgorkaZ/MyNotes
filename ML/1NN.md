# Метод одного ближайшего соседа

$x_{(u, 1)}$ - **ближайший сосед** объекта $u$ (см. [[Классификация на основе похожести#Похожесть|похожесть]]). Решает [[Задача классификации|задачу классификации]]. _Как-то_ можно решать [[Задача регрессии|задачу регрессии]]

$$
x_{(u,1)} = argmin_{\Large x\in X_{train}} \rho(u, x)
$$

#def Классификатор (одного) ближайшего соседа:
$$
a_{1NN}(u, \mathcal{D}_{train}) = y(x_{(u,1)})
$$
т.е. объект имеет тот же класс, что ближайший сосед

**Диаграмма Вороного**
![[Pasted image 20220412005453.png]]

Очень дорого обновлять, если надо добавить новый объект

### Плюсы
* Простота реализации
* Понятно
* Хорошо интерпретируется

### Минусы
* Чувствительность к шуму
* Низкое качество работы
* Нет обучаемых параметров (явно заданных)
	* Хорошо сработает только на хороших данных (хорошей диаграмме Вороного)
* Необходимость хранить все объекты
	* Вообще не надо хранить датасет как часть алгоритма, фу

### Мысли об улучшении
* Более сложная модель (больше параметров)
	* Например, как $k$ в [[kNN]]
* Уменьшать размерность
* Использовать эффективные структуры хранения данных
	* Обычно это [[K-d tree]]
* Прореживание объектво
* Фильтрация шума
* Выбор прототипов

### Анализ
[[kNN-like методы|Анализ]]
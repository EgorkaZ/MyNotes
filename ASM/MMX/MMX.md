# MMX
MultiMedia eXtension
(Что-то про видео и звук)
Набор SIMD инструкций

Хотим поприменять операцию к пачке значений

Добавляет команды для небольших типов данных (8-16 бит), позволяет одновременно выполнять команды над пачками данных сразу

Впервые появился в _Pentium MMX_

Компиляторы честно пытаются, но неть(

* [[MMX Регистры]]

## Команды

### MOVQ
Пересылает 64 бита в mm регистр

`MOVQ mm0, [eax]`

### MOVD
Пересылает 32 бита
Нельзя из _mm_ в _mm_ регистры
Только из обычных

Зануляет старшие биты, если пишем в _mm_ регистр

`MOVD mm0, eax`
`MOVD [eax], mm0`

### MOVDQ(A|U)
Пересылает 128 бит
MOVDQA - aligned (иначе фейлится)
MOVDQU - unaligned

### packss(wb|dw)

pack signed saturation

#### signed saturation
"знаковое насыщение"
Ужимаем, например, 32 бита в 16

* если чиселка помещается в 16 бит, она и будет
* если больше диапазона, то получим `MAX_INT16`
* если меньше диапазона, то получим `MIN_INT16`

#### packssdw

`packssdw mm0, mm1`

На входе:
mm1: `[p1: i32, p2: i32]`
mm0: `[p3: i32, p4: i32]`

На выходе:
mm0 `[p1: i16, p2: i16, p3: i16, p4: i16]`

При этом `pi` проходит через [[#signed saturation]]

![[packssdw_img.png]]

#### packsswb

Как [[#packssdw]], но интерпретирует данные не как набор DWORD'ов, а как WORD'ы

### packuswb

Как [[#packsswb]], но диапазон не (-127, 128), а (0, 255)

### punpck(L|H)(BW|WD|DQ)

`punpckhwd mm0, mm1`

На входе:
mm0: `[p1: i16, p2: i16, p3: i16, p4: i16]`
mm1: `[p5: i16, p6: i16, p7: i16, p8: i16]`

На выходе:
mm0: `[(p5, p1): i32, (p6, p2): i32]`

Если бы был `punpckLwd`, то были бы `(p7, p3)` и `(p8, p4)`

Зачастую второй аргумент - `0`
Тогда мы верхние два WORD'а превращаются в DWORD'ы

![[punpcklbw_img.png]]

### padd(b|w|d)

Складывает кусками. Не переполняется

### padd(s|us)(b|w)

Сложение со знаковым/беззнаковым насыщением

### psub..

Аналогично [[#padd b w d|padd]] и [[#padd s us b w|padd(s|us)]]

### pmul(l|h)w
Умножение для слов со знаком
* l - младшие 16 бит результата
* w - старшие 16 бит результата

### pmaddwd
`pmaddwd mm0, mm1`

На входе:
mm0: `[p1: i16, p2: i16, p3: i16, p4: i16]`
mm1: `[p5: i16, p6: i16, p7: i16, p8: i16]`

На выходе:
mm0: `[(p1 * p5 + p2 * p6): i32, (p3 * p7 + p4 * p8): i32]`

Ни в какой момент не происходит переполнений

### pcmp(eq|gt)(b|w|d)
Сравнение в C стиле
`false` <- `0`
`true` <- `-1` (все битики в _1_)

GT работает в знаковом режиме

### p(or|xor|and)

Битовая логика

### pandn

Как [[#p or xor and|pand]], но инвертирует dest

### psll(w|d|q)

Битовый сдвиг left logical

### psrl(rl)(w|d|q)

Битовый сдвиг right logical

### psra(w|d)

Битовый сдвиг right arithmetical

### emms

Очистить все регистры [[x87]]